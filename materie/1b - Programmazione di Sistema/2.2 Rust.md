 # Rust
 - Linguaggio di programmazione moderno, focalizzato su **correttezza**, **velocità** e supporto della **programmazione concorrente**.
 - Linguaggio **staticamente e fortemente tipato**, adatto alla *programmazione di sistema*.

## Problemi di sicurezza in C
```c
typedef struct Dummy {int a; int b;} Dummy;

void foo(void){
	Dummy *ptr = (Dummy*) malloc(sizeof(struct Dummy)); // Disposizione in memoria precisa
	ptr->a = 2048; // Riferimento leggero
	free(ptr); // Rilascio deterministico
}
```
- ptr è presente nello **stack** e punta ad un dato allocato nello **heap**.

```c
typedef struct Dummy {int a; int b;} Dummy;

void foo(void){
	Dummy *ptr = (Dummy*) malloc(sizeof(struct Dummy));
	Dummy *alias = ptr; // Pericolo! 2 riferimenti allo stesso oggetto
	free(ptr);

	int a = alias->a; // Uso di blocco rilasciato!
	free(alias); // Doppio rilascio!
}
```
- **Dangling pointer**

## Soluzioni di Rust
- Si appoggia ad un **sistema di validazione** dei tipi in fase di compilazione che impedisce i seguenti tipi di errore, individuati in fase di compilazione:
	- **Dangling pointer** = uso di puntatori ad aree di memoria già rilasciate.
	- **Doppi rilasci** = tentativo di restituire al sistema operativo un'area dimemoria già rilasciata.
	- **Corse critiche** = accesso a dati il cui contenuto è determinato dall'ordine di esecuzione di codice concorrente.
	- **Buffer overflow** = tentativi di accedere ad aree di memoria conrigue a quelle possedute da una variabile, ma non di sua pertinenza. (Overflow di un vettore)
	- **Iteratori invalidi** = accesso iterativo agli elementi contenuti in una collezione che viene modificata mentre l'iterazione è in corso.
	- **Overflow aritmetici** = esecuzione di operazioni aritmetiche che portano ad errori grossolani.
- Il linguaggio favorisce l'uso di **costrutti immutabili** e propone convenzione per limitare il rischio di compromissione dei dati.
- Il compilatore ottimizza in modo *aggressivo* dimensioni e velocità del codice generato.
	- Le strutture dati del linguaggio sono pensate per favorire l'uso della **memoria cache**.
	- La politica di invocazione è basata su **indirizzi statici**, che possono essere ottimizzati inline e non richiedono lookup table.
	- Sistema integrato di **gestione delle dipendenze** che facilita la condivisione del codice.

## Terminologia
- **Crate**
	- Unità di compilazione che può dare origine ad un programma eseguibile (binario) o ad una libreria.
	- Può contenere riferimenti a moduli contenuti in ulteriori file sorgenti.
- **Crate root**
	- File sorgente da cui parte il compilatore Rust per creare il modulo principale del crate.
- **Modulo**
	- Meccanismo usato per suddividere il codice il unità logiche differenti e regolarne la visibilità.
- **Package**
	- Insieme di uno o più *crates* volti a fornire un insieme di funzionalità (progetto).
	- Può contenere diversi eseguibili ma al più una libreria.

## Le basi
- Il punto di ingresso di un programma è `fn main(){...}`.
- Per stampare su **stdout** `print!(...)` oppure `println!(...)`.
	- Il primo parametro è una stringa di **formato**. Per ciascuna coppia di `{}` presente all'interno deve essere indicato un parametro successivo, il cui valore sostituirà le graffe.
	- `println!("Hello, {}!", "world"); // -> Hello, world!`
- Per stampare su **stderr** `eprint!(...)` oppure `eprintln!(...)`
- Per dichiarare le variabili:
	- `let x : i32 = 13;`