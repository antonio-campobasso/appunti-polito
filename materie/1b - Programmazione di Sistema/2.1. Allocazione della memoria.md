# Allocazione della memoria
- L'esecuzione di un programma avviene nel suo **spazio di indirizzamento**.
	- Insieme di locazioni di memoria accessibili tramite **indirizzo virtuale**.
	- Sottoinsieme di celle *indirizzabili*, gestito dal sistema operativo.
- Il sistema operativo/la libreria di esecuzione offrono aree diverse:
	- In funzione dell'utilizzo e del ciclo di vita.
	- Leggibili, scrivibili, eseguibili.

## Criteri d'accesso
- La corrispondenza tra indirizzi virtuali e pagine fisiche è corredata da **metadati**:
	- Definiscono quali **operazioni** sono **lecite in memoria**.
	- eXecute, Read, Write, Copy_on_write.
- Accessi a locazioni non mappate o in violazione dei criteri indicati comportano l'**interruzione** della CPU.
	- Il processo viene terminato.
	- Access violation (Windows), Segmentation violation (MacOS, Linux).

## Uso della memoria
- Quando un processo viene creato il suo spazio di indirizzamento viene popolato di diverse aree:
	- Ciascuna dotata di propri **criteri d'accesso**.
	- Funzuonali a supportare i *modelli di esecuzione*.
- **Codice eseguibile**
	- Contiene le istruzioni in codice macchina generate dal programma e dalle librerie.
	- Accesso in lettura ed esecuzione.
- **Costanti**
	- Insieme dei valori immutabili definiti dal programma.
	- Accesso in sola lettura.
- **Variabili globali**
	- Accesso in lettura/scrittura.


- **Stack**
	- Area nella quale sono allocate le variabili locali, argomenti ricevuti in ingresso, valore e indirizzo di ritorno.
	- Ad ogni invocazione di funzione lo stack si espande (verso il basso) di un blocco capace di contenere tutto quello che è richiesto dalla funzione.
	- Quando la funzione ritorna, lo stack si contrae, rilasciando lo spazio del blocco.
- **Heap (free store)**
	- Insieme di blocchi di memoria disponibili per l'allocazione dinamica.
	- Si accede al suo contenuto SOLO tramite puntatori, gestiti tramite funzioni di libreria (malloc, new, free).

### Ciclo di vita delle variabili
- Distinzioni di diverse classi di variabili da parte del modello di esecuzione del C.
	- **Globali** = hanno un indirizzo *fisso*, determinato dal compilatore e dal linker/loader.
			- Accessibili in ogni momento.
			- All'avvio del programma contengono l'eventuale valore di inizializzazione.
	- **Locali** = hanno un indirizzo *relativo* alla cima dello stack.
		- Ciclo di vita coincidente con quello della funzione/blocco in cui sono state dichiarate.
		- Valore iniziale casuale.
	- **Dinamiche** = hanno un indirizzo *assoluto*, determinato in fase di esecuzione.
		- Accessibili solo tramite puntatori.
		- Il programmatore ne controlla il ciclo di vita, il valore iniziale può essere inizializzato o meno.
		- Presuppone un'infrastruttura di supporto che offre meccanismi di allocazione e di rilascio (forniti dalla libreria di esecuzione e dal sistema operativo).

```C
// Per ottenere un puntatore dinamico in C
void* malloc(size_t s);
void* calloc(int n, size_t s);
void* realloc(void *p, size_t s);

free()
```

``` C++
// C++
new NomeTipo(argomenti...);
new (std::nothrow) NomeTipo(argomenti...); // Non genera un'eccezione e restituisce un puntatore non valido (nullptr)
new NomeTipo[]; // Ritorna il puntatore all'inizio dell'array

delete
delete[]
 
```

## Puntatori
- Permettono l'accesso diretto ad un blocco di memoria
```c++
int A = 10;
int *pA = &A; // puntatore appartenente ad altri oggetti

int *pB = new int(32); // puntatore allocato allo scopo

// Puntatori invalidi
il valore 0
la macro NULL ((void*)0)
la parola chiave nullptr (preferita)
```
