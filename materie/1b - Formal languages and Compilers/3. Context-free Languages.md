# Parse trees
- Defined as a tree $G = (N, T, P, S)$ where:
	- The **root** is labeled by the start symbol $S$.
	- Each interior **node** is labeled by a symbol in $N$.
	- Each **leaf** is labeled by a symbol in $N \cup T \cup \{ \epsilon \}$.
	- An interior node labeled by $A$ has children (from left to right) labeled by $X_1, X_2, ..., X_k$ only if $A \rightarrow X_1, X_2, ..., X_k$ is a production in $P$.
- A **yield** of a parse tree is a string obtained by concatenating (from left to right) the labels of the leaves.
- Leftmost/Rightmost derivation.

- Every string in CFL has **at least** one parse tree.
	- Each parse tree has just one leftmost derivation and one rightmost derivation.
- A **Context-free grammar** is *ambiguous* if there is at least one string in his language having 2 different parse trees.
- A **Context-free language** is *inherently ambiguous* if all its grammars are ambiguous.  

## Eliminating useless symbols
- A symbol is useful for a CFG if it can be **reached** (after some derivation) from a start symbol and can **generate a non-empty language**.

## $\epsilon$-production
- According to Chonsky classification only type 0 grammar can have $\epsilon$-production.
- But languages generated by CFG that have $\epsilon$-production are CFL.
- CFG with $\epsilon$-production can be transformed in CFG without.
	- The new grammar will have 2 rules, one that include the $\epsilon$ generating symbol and the other that does not.

# PDA (Pushdown Automata)
- A **PDA** is a 7-tuple $P=(Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$ 
	- $Q$ = finite (non empty) set of **states**.
	- $\Sigma$ = alphabet of **input** symbols.
	- $\Gamma$ = alphabet of **stack** symbols.
	- $\delta$ = **transition** function.
		- $\delta = Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \rightarrow \wp (\{(p,\gamma) | p \in Q ; \gamma \in \Gamma^*\})$
	- $q_0$ = **start** state $(q_0 \in Q)$.
	- $Z_0$ = **start stack symbol** $(Z_0 \in \Gamma)$.
	- $F$ = set of **final states** $(F \subseteq Q)$.
- The state is changed based on the input and the stack.

## Transitions
- $\delta(q,a,X) = \{(p_1, \gamma_1), (p_2, \gamma_2), ..., (p_m, \gamma_m)\}$
- $\delta(q,\epsilon,X) = \{(p_1, \gamma_1), (p_2, \gamma_2), ..., (p_m, \gamma_m)\}$

- From state $q$, with $X$ on top of the stack.
- Consumes $a$ from the input string (or no symbol if $\epsilon$).
- Goes to a state $p_i$ and replaces $X$ with $\gamma_i$.

## Deterministic PDA
- The delta function returns a single element and not a set.
- If a symbol produces something, the epsilon-transition(consuming no symbols) must return the empty set.

## PDA Languages $\equiv$ CFL  
- CFL are closed under:
	- Union
	- Concatenation
	- Kleene closure