# Regular languages
Regular sets are another way of **representing** a regular language without referring to the concept of grammar.

**Regular sets** over an alphabet:
- $\emptyset$.
- The set $\{\epsilon\}$ containing the **empty string**.
- The set $\{a\}$ containing any **symbol** of the alphabet.

If P and Q are regular sets over an alphabet, the same is true for:
- The **union** $P \cup Q$
- The **concatenatuon** $P Q = {xy \mid x \in P; y \in Q}$
- The **closures** $P^*$ and $Q^*$

**Regular expressions** represent **regular sets**.

**Regular expressions** of an alphabet:
- the expression $\phi$, denoting the empty set $\emptyset$.
- the expression $\epsilon$, denoting the set containing the empty string $\{\epsilon\}$.
- the expression a, denoting the set containing any symbol of the alphabet $\{a\}$.

if p and q are regular expression over an alphabet, the same is true for:
- the expression p | q, denoting $P \cup Q$.
- the expression p q, denoting the set $P Q$.
- the expression p* and q*, denoting the set $P^*$ and $Q^*$.


**Algebraic** properties are defined for regular expression
![[alg prop.png]]

## Equations of regular expressions
- If $\alpha$ and $\beta$ are regular expressions, $X = \alpha X \mid \beta$ is an equation with unknown $X$.
	- $X = \alpha^* \beta$ is a solution of the equation.
- A set of equations with unknowns $\{X_1, X_2, ..., X_n\}$ is composed by **n** equations such as:
$$X_i = \alpha_{i0} \mid \alpha_{i1} X_1 \mid \alpha_{i2} X_2 \mid ... \mid \alpha_{in} X_n$$
- Where each $a_{ij}$ is a **regular expression** over any alphabet *without unknowns*.

### Solutions of sets of equations
- Loop forward over all the equations
	- Put the equation **i** in the form $X_i = \alpha X_i | \beta$
	- Substitute $X_i$ with $\alpha^*\beta$ in equations i+1, i+2, ..., n
- Loop backwards over all the equations
	- The i-th equation is in the form $X_i = \alpha * \beta$, where $\alpha$ and $\beta$ do not contain unknowns.
	- Solve the i-th equation: $X_i = \alpha^* \beta$
	- Substitute $X_i$ with $\alpha^*\beta$ in equations i-1, i+2, ..., 1

### Regular sets and linear languages
#### Right-linear languages subset of regular sets
- Let $G = (\{A_1, A_2, ..., A_n\}, T, P, A_1)$ be a right-linear grammar.
- Let us transform each rule of the grammar into an **equation** of regular expressions.
- The language $L(G)$ generated by the grammar is denoted by the regular expression corresponding to the symbol $A_1$.


#### Regular sets subset of right-linear languages
The regular sets: $\emptyset, \{\epsilon\}, \{a | a \in \Sigma\}$ can be generated by right-linear grammars.

- $G_1 = (\{S\}, \Sigma, \emptyset, S) \rightarrow L(G_1) = \emptyset$
- $G_2 = (\{S\}, \Sigma, \{S \rightarrow \epsilon\}, S) \rightarrow L(G_2) = \{\epsilon\}$
- $G_3 = (\{S\}, \Sigma, \{S \rightarrow a | a \in \Sigma\}, S) \rightarrow L(G_3) = \{a\}$ where $a \in \Sigma$

- Consider 2 right-linear grammars with **distinct non-terminal sets**.
- $G_1 = (N_1, \Sigma, P_1, S_1)$ and $G_2 = (N_2, \Sigma, P_2, S_2)$

- The language created by the **union** of the languages created by the grammars is also right-linear.
	- His non **terminal set** is made of the **union** of the **non terminal sets** plus a **new symbol** which is also the **start symbol of the new grammar**.
	- **New rule**: the new start symbol can generate either the start symbols of the original grammars.
- $G_4 = (N_1 \cup N_2 \cup \{S_4\}, \Sigma, P_1 \cap P_5, S_1)$

- The language created by the **concatenation** of the languages created by the grammar is also right-linear.
	- His **non terminal set** is the **union** of the **non terminal sets**.
	- The **start symbol** is the **start symbol of the first grammar**.
	- **The rules** are made of the **union** of the **rules of the second grammar** and a **new set of rules**.
- $G_4 = (N_1 \cup N_2 \cup \{S_4\}, \Sigma, P_1 \cap P_5, S_1)$
- $P_5 = A \rightarrow xB$ if $A \rightarrow xB \in P_1$
	- $= A \rightarrow xS_2$ if $A \rightarrow x \in P_1$

- The language created by the **closure** of the language created by the grammar is also right-linear.
- $G_6 =(N_1 \cup \{S_6\}, \Sigma, \{S_6 \rightarrow S_1 |\epsilon\} \cup P_6, S_6)$.
- $P_5 = A \rightarrow xB$ if $A \rightarrow xB \in P_1$
	- $= A \rightarrow xS_6$ if $A \rightarrow x \in P_1$

#### Additional proofs
right-linear = regular sets
left-linar = regular sets
right-linear = left-linear

# Deterministic finite automata (DFA)
- 5-tuple $A = (Q, \Sigma, \delta, q_0, F)$
	- $Q$ = finite (not empty) set of **states**.
	- $\Sigma$ = alphabet of **input** symbols.
	- $\delta$ = **transition** function.
		- $\delta: Q \times \Sigma \rightarrow Q$
	- $q_0$ = **start** state.
		- $q_0 \in Q$
	- $F$ = set of **final states**.
		- $F \subseteq Q$

- **Transition table**
	- Tabular rapresentation of the transition function.
- **Transition diagram**
	- A graph where:
		- For each state in the automaton there is a node
		- For each transition there is an arc
		- the start state has an entering non labeled arc.
		- the final state is marked by a double circle.

![[Pasted image 20220308152935.png]]

## The language accepted by a DFA
- The domain of function $\delta$ can be extended from $Q \times \Sigma$ to $Q \times \Sigma^*$:
	- $\delta(q, \epsilon) = q$
	- $\delta(q, aw) = \delta(\delta(q,a),w)$ where $a \in \Sigma; w \in \Sigma^*$.
- Language accepted by the automaton:
$$L(A) = \{ W \mid w \in \Sigma^* ; \delta(q_0, w) \in F \}$$ 
# Non-deterministic finite automata (NFA)
- 5-tuple $A = (Q, \Sigma, \delta, q_0, F)$
	- $Q$ = finite (not empty) set of **states**.
	- $\Sigma$ = alphabet of **input** symbols.
	- $\delta$ = **transition** function.
		- $\delta: Q \times \Sigma \rightarrow \wp(Q)$ 
		- Power-set of Q = the set of all subsets $||\wp(Q)|| = 2^{||Q||}$.
	- $q_0$ = **start** state.
		- $q_0 \in Q$
	- $F$ = set of **final states**.
		- $F \subseteq Q$

>A string is accepted by the automata if after an undefined number of transition it can arrive to a final state.

- A **DFA** is a special case of **NFA**.
	- Given and **NFA** it is possible to build a **DFA** that accepts the same regular language. #TODO riporta algoritmo
- The transition function can also return an empty set, and therefore no state.

# Finite automata and regular sets
- It is possible to eliminate states in a **FA** by:
	- **Maintaining** all the paths and **labeling** the transitions with **regular expressions**.

## $\epsilon$-NFA
- This kind of transition makes any **FA** into a **NFA**.
- The function $\epsilon$-closure (q) gives the set of states that can be reached (recursively) from state q with the empty string.
- #TODO algoritmo per convertire in DFA

# Minimum state DFA
- Consider a DFA **completely specified**.
- Two states $p$ and $q$ are **distinguishable** if there is a string $w \in \Sigma^*$ such that $\delta(p,w) \in F$ and   $\delta(q,w) \notin F$.
	- Otherwise they are **equivalent** ( $p \equiv q$ ) and can be merged in one state.
- A DFA is **minimum-state** if it does not contain equivalent states.
- Two states are **m-equivalent** if they are non-distingushable for all the strings with length less than m.

# Operations with regular languages
## Equivalence of regular languages
- Let $DFA_1 = (Q_1, \Sigma, \delta_1, q_{01}, F_1)$ and $DFA_2 = (Q_2, \Sigma, \delta_2, q_{02}, F_2)$.
- Let us find the equivalence states in the set $Q_1 \cup Q_2$.
- If $q_{01} \equiv q_{02}$ then $L(DFA_1) = L(DFA_2)$.

## Complement of regular languages
- Consider a DFA **completely specified**.
- Defined as $DFA_C = (Q, \Sigma, \delta, q_0, Q-F)$ and it is also a regular language.
	- Accepts the language $L(DFA_C) = \Sigma^* - L(DFA) = \neg L(DFA)$

## Intersection of regular languages
- It is also a **regular language**.
- $L_1 \cap L_2 = \neg (\neg L_1 \cup \neg L_2)$
	- De Morgan law.
- Another way to derive it is by the **product automaton**.
	- Let $DFA_1 = (Q_1, \Sigma, \delta_1, q_{01}, F_1)$ and $DFA_2 = (Q_2, \Sigma, \delta_2, q_{02}, F_2)$.
		- The automaton $DFA = (Q_1 \times Q_2, \Sigma, \delta, (q_{01}, q_{02}), F_1 \times F_2)$ where $\delta ((p,q)a) = (delta_1 (p,a), \delta_2 (q,a)))$ accepts the language:
		- $L(DFA) = L(DFA_1) \cap L(DFA_2)$.