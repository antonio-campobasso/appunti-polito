#TODO rivedi prima lezione

- Il class model può essere associato ad elementi di un linguaggio orientato agli oggetti (java), ma anche a modelli di database relazionali.
- Oltre ad operazioni CRUD, è necessario poter aggiungere e rimuovere relazioni.

### Attributi associativi

![[1. Sviluppo del Software_We 02_03 - 08_38.excalidraw]]

- Solitamente si attribuisce il nome della **classe** (singolare o plurale).
- Possono essere sottointesi.

### Relazione ricorsiva

![[1. Sviluppo del Software_We 02_03 - 08_45.excalidraw]]

- La relazione simmetrica presenta gli stessi **attributi associativi**.

## Condizioni
- Sulla base del modello classi-relazioni si possono definire dei **vincoli** che riguardano le operazioni relative al sistema rappresentato.
- I vincoli sono basati su **espressioni navigazionali**.
- L'UML propone il linguaggio **OCL**.

### Espressioni navigazionali
``` OCL 
// Data un'entità e //

e.projects -> Fornisce i progetti dell'impiegato e - 1 step
e.projects.department -> Fornisce i dipartimenti dei progetti a cui lavora - 2 step
[e.projects] -> Fornisce il numero dei progetti dell'impiegato
```

- Il risultato di una navigazione può essere un **oggetto**, un **valore**, una **collezione** di oggetti o di valori.

#### Filtri e operatori
``` OCL
// Data un'entità e //

e.projects (p, p.budget > 1000)
	-> Fornisce i progetti dell'impiegato e con budget > 1000

(min e max)
e.projects.max(budget) -> Fornisce l'oggetto con budget maggiore
e.projects.budget.max -> Fornisce il budget maggiore

(average e sum)
e.projects.average(budget) -> Fornisce la media del budget
oppure
e.projects.budget.average 

```

- **p** è un cursore che indica l'oggetto corrente.

#### Entità contestuali
``` OCL


with Department d, Project p : d.employees (e, e.projects include p)
	-> Fornisce gli impiegati di d che lavorano al progetto p

```

### Invarianti
Condizioni che valgono sempre.

`[employee.projects] <= 3`
- Il nome della classe con iniziale minuscola indica **ogni** elemento della classe e ha valenza di **quantificatore universale**.

`employee.department def`
- L'attributo deve essere definito (non nullo).
- In alternativa si può indicare la relazione **necessaria** nel class-model, *sottolineando* la molteplicità.

### Regole di validazione
Si verificano su richiesta.

`department.head in department.employees`

#### Altri operatori
#TODO spostare in sezione appropriata

`order.orderLines.ProductType distinct`
- I product type associati alla order line devono essere distinti

 `order.orderLines(0)`
- Indica il primo elemento di una collezione ordinata

### Operazioni
- I vincoli si esprimono mediante **pre-condizione**.
- Il risultato si esprime mediante **post-condizione**.

``` OCL
// Inserimento di un nuovo impiegato in un dipartimento purchè non si superi il max numero di impiegati 10

with Department department // Scelta del dipartimento
pre: [department.employees] < 10 // Vincolo di scelta
post: new Employee e, e.department == department
```

- Si può omettere la condizione **pre**, dato che può essere espressa tramite **molteplicità**.
- Data la presenza dell'**attributo associativo** *department* l'inserimento di un nuovo employee comporta l'associazione del departimento.

``` OCL
with Department department 
post: new Employee e
```

#### Scrivere un object-model
``` OCL

new Node a;
new Node b;
new Node c;

b in a.neighbors;
c in a.neighbors;
c in b.neighbors;

// le relazioni sono simmetriche

```

### Attributi
Possono essere:
- **Richiesti** = devono essere inizializzati quando l'oggetti è istanziato. Possono essere attributi ordinari o *associativi*.
	- Indicati con un nome *sottolineato*.
- **Derivati** = ottenuto, quando richiesto, da attributi ordinari oppure derivati.
	- Viene definito tramite **navigazione** e operazioni algebriche.

È possibile anche definire **relazioni derivate** attraverso attributi:
`Order - ProductType = Order - OrderLine - ProductType`
diventa:
``` OCL
Order: Set<ProductType> productTypes = orderLines.productType

ProductType: Set<Order> orders = orderLines.order
```

## Definizione dei requisiti
- Si dividono in 2 categorie principali:
	- **Requisiti funzionali** = riguardano il funzionamento del sistema affichè soddisfi le richieste del customer. Spesso includono **requisiti strutturali**.
	- **Requisiti non-funzionali (vincoli)** = riferiti a prestazioni e standard.

- I requisiti devono essere:
	- **Ben definiti** = una singola interpretazione.
	- **Consistenti** = nessun conflitto con altri requisiti.
	- **Verificabili** = la soddisfazione può essere verificata/misurata in maniera efficace.
	- **Completi** = trattano tutti gli aspetti rilevanti.

**Tracciabilità dei requisiti**:
- *Forward* = da un requisito ai sottosistemi che lo soddisfano.
- *Backward* = dai sottosistemi ai requisiti.

### Analisi dei requisiti
#TODO vedi slide

# Model-driven development
1. Si ricava il **domain model** (classi relazione UML) con attributi e regole (*invarianti*).
2. Si modellano le attività degli utenti con **use cases** UML.
3. I casi d'uso rappresentano task ai quali sono associate precondizioni per i vincoli e postcondizioni per gli effetti.

## Esempio
The library contains **books** : book attributes include *id, title, authors, publisher*. Books are added by **librarians** ( **Members** are the persons entitled to get books on loan) . Members are enrolled by librarians: the *enrollment date* and the librarian who made the enrollment must be recorded. Member attributes include name, address, email. A *personal id* is provided by the enrollment procedure.
A librarian has a *name* and an *id*. To borrow a book, members must open a **loan**. First, they get a list of books by specifying *subject* and *authors*, then they choose an item from the list. The loan is *opened* if the book is available and the number of open loans of the member does not exceed the limit (6 ). The duration of the loan is 14 days. Members cannot borrow additional books if they have some loans overdue. When a member returns a book, the system closes the loan associated with the book id.

A loan has two dates: the *end date* and the *due date*. The end date is **set when the loan is closed**.
An ongoing (past) loan has the end date undefined (defined When a loan is one week overdue, the system sends a reminder to the borrower of the book. The major states of a loan are ongoing, past, overdue. Members can update personal information such as address and email.
Librarians can make inquiries on ongoing and past loans.

![[Pasted image 20220307101105.png]]

### Use cases
- Presenta le attibità degli utenti di un sistema.
- Contengono descrizioni delle interazioni tra l'utente e il server.
- Possono essere raggruppati in **subjects**.
- Possono esserci relazioni di *inclusione* e relazioni di *estensione*.

![[Pasted image 20220307102023.png]]

#### Descrizione di returnBook
1. User inputs search parameters ( title and authors).
2. System displays a list of available books.
3. User chooses a book.
4. If all constraints are met , System opens a new loan and the use case
ends; otherwise User is sent back to step 1.